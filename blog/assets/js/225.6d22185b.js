(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{722:function(t,s,a){"use strict";a.r(s);var n=a(22),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"异步-io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-io"}},[t._v("#")]),t._v(" 异步 IO")]),t._v(" "),a("p",[t._v("nodejs 的核心优势就在于异步 IO 的处理能力，因此肯定要重点展开讲解。其实细想一下，做一个 web server 无非就是处理 http 请求，本质上不就是 IO 吗？")]),t._v(" "),a("h2",{attrs:{id:"js-单线程异步的特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-单线程异步的特性"}},[t._v("#")]),t._v(" JS 单线程异步的特性")]),t._v(" "),a("p",[t._v("说到“异步 IO”，就先来说说“异步”。")]),t._v(" "),a("h3",{attrs:{id:"js-异步很重要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-异步很重要"}},[t._v("#")]),t._v(" JS 异步很重要")]),t._v(" "),a("p",[t._v("第一节讲解语法知识的时候，就强调过必须熟练掌握 JS 异步的相关知识，列出如下知识点。还推荐不熟悉的同学去阅读作者写的 "),a("a",{attrs:{href:"https://github.com/wangfupeng1988/js-async-tutorial",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解 JS 异步"),a("OutboundLink")],1),t._v(" 。")]),t._v(" "),a("ul",[a("li",[t._v("异步和同步的区别")]),t._v(" "),a("li",[t._v("异步和单线程")]),t._v(" "),a("li",[t._v("event loop")]),t._v(" "),a("li",[t._v("callback 方式")]),t._v(" "),a("li",[t._v("Promise")]),t._v(" "),a("li",[t._v("async/await")])]),t._v(" "),a("h3",{attrs:{id:"单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[t._v("#")]),t._v(" 单线程")]),t._v(" "),a("p",[t._v("这里重点说一说单线程，因为它和下文有很大的联系。")]),t._v(" "),a("p",[t._v("我们都知道 JS 是一门单线程执行的语言，无法用 JS 代码新启动一个线程。什么是单线程，通俗来说就是单一时间只能做一件事，不能“一心二用”。例如")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sum\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100000000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sum"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("如上代码中，要执行 100000000 次循环，是非常耗费时间的，但是 JS 也只能这么来执行：先打印"),a("code",[t._v("100")]),t._v("，然后执行一个漫长的 for 循环（此处可能需要等待很久），最后打印"),a("code",[t._v("200")]),t._v("。那我们可不可以一边执行 for 循环，一边打印"),a("code",[t._v("200")]),t._v("呢？两者不受影响啊，一起执行也完全 OK 啊 —— 但是答案是不可以，如果一起执行的话，那就是多线程的了，JS 只能是单线程执行。")]),t._v(" "),a("h3",{attrs:{id:"为何要单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何要单线程"}},[t._v("#")]),t._v(" 为何要单线程")]),t._v(" "),a("p",[t._v("JS 为何非得要单线程呢，像 java 那样做成多线程的不行吗？答案是不行。")]),t._v(" "),a("p",[t._v("在浏览器环境中，JS 是可以操作 DOM 结构的，而 DOM 只有一份。如果两段 JS 能同时执行的话，那么它们都同时操作同一个 DOM 节点，不就发生冲突了吗？因此，"),a("strong",[t._v("为了避免 DOM 操作的冲突，JS 不能同时执行，只能单线程执行")]),t._v("。另外，不光 JS 是单线程，而且 JS 和浏览器渲染公用一个线程，即 JS 执行时，浏览器渲染会等待、卡顿。")]),t._v(" "),a("p",[t._v("最后，单线程使得 JS 入门简单使用方便，也不会出现线程思索、状态同步的琐碎问题，简单才容易做大、做广，大道至简。")]),t._v(" "),a("h3",{attrs:{id:"延伸到-nodejs-中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#延伸到-nodejs-中"}},[t._v("#")]),t._v(" 延伸到 nodejs 中")]),t._v(" "),a("p",[t._v("nodejs 借用了 Chrome 浏览器中的 v8 引擎来解析 JS ，因此就将其单线程的特性保留了下来。但是 nodejs 提供了 Child_Process 和 Cluster 来操作进程，能解决单线程遇到的一些问题，下一节会介绍。")]),t._v(" "),a("h3",{attrs:{id:"解决单线程-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决单线程-异步"}},[t._v("#")]),t._v(" 解决单线程 - 异步")]),t._v(" "),a("p",[t._v("上文那 100000000 次循环纯粹为了演示，实际项目中不会存在这样的场景 —— 即不会存在 CPU 计算成为速度上的瓶颈，而是网络或者文件读写成为速度上的瓶颈。")]),t._v(" "),a("p",[t._v("网络请求和文件读写遇到性能瓶颈这是很正常的，那对于 JS 这种单线程的语言，该怎么办呢？—— 难道执行一次网络请求，就要一直等到网络请求结束（可能花费 1s 5s 甚至 10s）之后才能继续执行下去？—— 当然不是，JS 解决这个问题就是用了异步。")]),t._v(" "),a("p",[t._v("好了，讲到这里讲出了异步，就不在继续了，再将就是异步的语法了。")]),t._v(" "),a("h2",{attrs:{id:"什么是-io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-io"}},[t._v("#")]),t._v(" 什么是 IO")]),t._v(" "),a("p",[a("strong",[t._v("所谓 IO ，就是 input 和 output ，即输入和输出。")])]),t._v(" "),a("p",[t._v("当 JS 运行在浏览器端的时候就有 IO ，且只有一种 IO —— 网络 IO ，即 http 请求。例如 ajax 或者异步加载 script 和图片。当 JS 运行在 server 端时，IO 是最常见的，除了计算，剩下的就是 IO ，可以总结为两类：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("网络 IO")]),t._v(" ：通过网络请求访问其他机器或者服务器的数据，或者提交数据")]),t._v(" "),a("li",[a("strong",[t._v("文件 IO")]),t._v(" ：读取文件内容，或者写内容到文件里")])]),t._v(" "),a("p",[t._v("无论针对哪个语言、哪个框架、哪个操作系统，"),a("strong",[t._v("IO 都有一个不变的特点 —— 慢")]),t._v(" 。现在 CPU 的计算速度是非常快的，相比之下，读取硬盘和等待网络请求就变的非常缓慢。大家应该也能经常听到“IO 瓶颈”之类的词，这就表示其他地方很快，就卡在 IO 这块了，因此叫做“瓶颈”。")]),t._v(" "),a("p",[t._v("慢，但是肯定是有解决方案的。")]),t._v(" "),a("h2",{attrs:{id:"多线程-web-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程-web-server"}},[t._v("#")]),t._v(" 多线程 web server")]),t._v(" "),a("p",[t._v("PHP 也没法创建线程，即也是单线程执行的，而且 PHP 也没有 JS 一样的异步，遇到 IO 的时候只能等待完成之后再继续下一步的执行。但是 PHP 作为世界上最好的语言，肯定有解决方案。")]),t._v(" "),a("p",[t._v("这个解决方案不是 PHP 搞定的，而是 web server 服务器搞定的，例如 Apache 。Apache 服务器每接收一个 http 请求都会新建一个线程，在该线程这个封闭的环境下执行 PHP 代码。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("好处")]),t._v("：就是处理各个 http 请求在每个独立的线程中，上下文相互独立，不相互影响，独立性好。")]),t._v(" "),a("li",[a("strong",[t._v("坏处")]),t._v("：就是 http 并发量大了之后，创建如此多线程内存吃不消，因此会有著名的 "),a("a",{attrs:{href:"http://www.kegel.com/c10k.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("C10K"),a("OutboundLink")],1),t._v(" 问题。")])]),t._v(" "),a("p",[t._v("（关于以上内容：笔者不是专业搞 PHP 的，有解释不到位的，欢迎补充）")]),t._v(" "),a("h2",{attrs:{id:"异步-io-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步-io-2"}},[t._v("#")]),t._v(" 异步 IO")]),t._v(" "),a("p",[t._v("相比上文 Apache 多线程的方式，nodejs 针对所有 http 请求，都只有一个线程。先解释一下，这里说的单线程和下一节将的多进程不是一回事，一个是线程一个是进程，不要混了。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("好处")]),t._v("：减少线程开销，能承受更多的 http 的并发请求。著名的 nginx 也是用类似的方式做到高性能的。")]),t._v(" "),a("li",[a("strong",[t._v("坏处")]),t._v("：所有 http 请求公用一个线程，一个上下文，一点崩溃即权限崩溃，对于程序的稳定性要求搞")])]),t._v(" "),a("p",[t._v("到这里就接上了本文一开始将的话题 —— 单线程的解决方案就是异步，IO 是瓶颈，那就用异步处理 IO，即 "),a("strong",[t._v("异步 IO")]),t._v(" ，即 nodejs 用单线程、异步的方式处理 IO 时能支持更多的并发请求。")]),t._v(" "),a("p",[t._v("上文说过，nodejs 中最常见的 异步 IO ，第一是 网络 IO，第二是 文件 IO ，至于详细的语法和 API 用法，就不再详细演示了，不是本文的重点。")]),t._v(" "),a("p",[a("strong",[t._v("【扩展】事件监听算不算异步？")])]),t._v(" "),a("p",[t._v("前端代码如")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#btn1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'click'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("event")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("nodejs 代码如")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("req"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("on")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'data'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("chunk")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("这种将 callback 函数作为参数传递的形式，看着都像是异步。这里就提出一个疑问吧，想搞清楚这个疑问就必须要详细了解 event loop ，推荐大家去看一个视频 "),a("a",{attrs:{href:"https://pan.baidu.com/s/1i6slMiL",target:"_blank",rel:"noopener noreferrer"}},[t._v("what the hack is event loop"),a("OutboundLink")],1),t._v("（看不了就下载），也可以看作者写的 "),a("a",{attrs:{href:"https://github.com/wangfupeng1988/js-async-tutorial/blob/master/part1-basic/03-event-bind.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("这篇文章"),a("OutboundLink")],1),t._v(" 。")]),t._v(" "),a("h2",{attrs:{id:"异步编程的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的问题"}},[t._v("#")]),t._v(" 异步编程的问题")]),t._v(" "),a("p",[t._v("关于异步编程的问题和解决方案，我在 "),a("a",{attrs:{href:"https://github.com/wangfupeng1988/read-notes/blob/master/book/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnodejs.md#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("《深入浅出 nodejs》读书笔记"),a("OutboundLink")],1),t._v(" 中整理的比较详细，可以直接去参考，没必要再拷贝一遍。")]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("本文关于异步的语法和 API 一点都没讲，但是本文内容却很多。能了解 "),a("strong",[t._v("异步 IO")]),t._v(" "),a("strong",[t._v("单线程")]),t._v(" 等这些底层概念，比知道语法和 API 用法更重要。")])])}),[],!1,null,null,null);s.default=r.exports}}]);